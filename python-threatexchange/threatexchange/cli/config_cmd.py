#!/usr/bin/env python
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

"""
Config command to setup the CLI and settings.
"""

import argparse
from dataclasses import is_dataclass, Field, fields, MISSING
import json
import typing as t
from threatexchange import common

from threatexchange.cli.cli_config import CLISettings

from threatexchange.cli import command_base
from threatexchange.cli.exceptions import CommandError
from threatexchange.fetcher.fetch_api import SignalExchangeAPI
from threatexchange.fetcher.apis.static_sample import StaticSampleSignalExchangeAPI
from threatexchange.signal_type.signal_base import SignalType


class ConfigCollabListCommand(command_base.Command):
    """List collaborations"""

    @classmethod
    def get_name(cls) -> str:
        return "list"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        pass

    def execute(self, settings: CLISettings) -> None:
        for collab in settings.get_all_collabs():
            print(collab.name)


class _UpdateCollabCommand(command_base.Command):
    """
    Create or edit collaborations for this API

    Programatically generated by inspecting the config class, so not everything will be
    documented.
    """

    _API_CLS = SignalExchangeAPI

    _IGNORE_FIELDS = {
        "name",
        "api",
        "enabled",
        "only_signal_types",
        "not_signal_types",
        "only_owners",
        "not_owners",
        "only_tags",
        "not_tags",
    }

    @classmethod
    def get_name(cls) -> str:
        return cls._API_CLS.get_name()

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        cfg_cls = cls._API_CLS.get_config_class()
        assert is_dataclass(cfg_cls)

        ap.add_argument("collab_name", help="the name of the collab")
        ap.set_defaults(api_name=cls._API_CLS.get_name())
        on_off = ap.add_mutually_exclusive_group()
        ap.add_argument(
            "--create",
            "-C",
            action="store_true",
            help="indicate you intend to create a config",
        )
        # This goofy syntax allows --enable, --enable=1, and enable=0 to disable
        on_off.add_argument(
            "--enable",
            nargs="?",
            type=int,
            const=1,
            choices=[0, 1],
            help="enable the config (default on create)",
        )
        on_off.add_argument(
            "--disable",
            dest="enable",
            action="store_const",
            const=0,
            help="disable the config",
        )
        ap.add_argument(
            "--only-signal-types",
            "-s",
            nargs="*",
            type=common.argparse_choices_pre_type(
                [s.get_name() for s in settings.get_all_signal_types()],
                settings.get_signal_type,
            ),
            metavar="NAME",
            help="limit to these signal types",
        )
        ap.add_argument(
            "--not-signal-types",
            "-S",
            nargs="*",
            type=common.argparse_choices_pre_type(
                [s.get_name() for s in settings.get_all_signal_types()],
                settings.get_signal_type,
            ),
            metavar="NAME",
            help="dont use these signal types",
        )
        ap.add_argument(
            "--only-owners",
            "-o",
            nargs="*",
            type=int,
            metavar="ID",
            help="only use signals from these owner ids",
        )
        ap.add_argument(
            "--not-owners",
            "-O",
            nargs="*",
            type=int,
            metavar="ID",
            help="dont use signals from these owner ids",
        )
        ap.add_argument(
            "--only-tags",
            "-t",
            nargs="*",
            metavar="TAG",
            help="use only signals with one of these tags",
        )
        ap.add_argument(
            "--not-tags",
            "-T",
            nargs="*",
            metavar="TAG",
            help="don't use signals with one of these tags",
        )
        ap.add_argument(
            "--json",
            "-J",
            dest="is_json",
            action="store_true",
            help="instead, interpret the argument as JSON and use that to edit the config",
        )

        for field in fields(cfg_cls):
            cls._add_argument(ap, field)

    @classmethod
    def _add_argument(cls, ap: argparse.ArgumentParser, field: Field) -> None:
        if not field.init:
            return
        if field.name in cls._IGNORE_FIELDS:
            return
        assert not isinstance(
            field.type, t.ForwardRef
        ), "rework class to not have forward ref"
        ap.add_argument(
            f"--{field.name.replace('_', '-')}",
            type=t.get_origin(field.type) or field.type,
            help="[auto generated from config class]",
        )

    def __init__(
        self,
        namespace,
        create: bool,
        name: str,
        enabled: t.Optional[int],
        only_signal_types: t.Optional[t.List[SignalType]],
        not_signal_types: t.Optional[t.List[SignalType]],
        only_owners: t.Optional[t.List[int]],
        not_owners: t.Optional[t.List[str]],
        only_tags: t.Optional[t.List[str]],
        not_tags: t.Optional[t.List[str]],
        is_json: bool,
    ) -> None:
        self.namespace = namespace
        self.create = create
        self.edit_kwargs = {}
        self.name = name
        if is_json:
            self.edit_kwargs = json.loads(name)
            self.name = self.edit_kwargs["name"]

        # Technically you could combine this and JSON, but you'd be weird
        if enabled is not None:
            self.edit_kwargs["enabled"] = bool(enabled)
        if only_signal_types is not None:
            self.edit_kwargs["only_signal_types"] = {
                s.get_name() for s in only_signal_types
            }
        if not_signal_types is not None:
            self.edit_kwargs["not_signal_types"] = {
                s.get_name() for s in not_signal_types
            }
        if only_owners is not None:
            self.edit_kwargs["only_owners"] = set(only_owners)
        if not_owners is not None:
            self.edit_kwargs["not_owners"] = set(not_owners)
        if only_tags is not None:
            self.edit_kwargs["only_tags"] = set(only_tags)
        if not_tags is not None:
            self.edit_kwargs["not_tags"] = set(not_tags)

    def execute(self, settings: CLISettings) -> None:
        existing = settings.get_collab(self.name)

        if existing:
            if self.create:
                raise CommandError(
                    f'there\'s an existing collaboration named "{self.name}"', 2
                )
            if existing.api != self._API_CLS.get_name():
                raise CommandError(
                    f"the existing collab is for the {existing.api} api, delete that one first",
                    2,
                )

        settings._state.update_collab()


class ConfigCollabForAPICommand(command_base.CommandWithSubcommands):
    """Create and edit collaborations for APIs"""

    @classmethod
    def get_name(cls) -> str:
        return "edit"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        apis = settings.get_fetchers()
        cls._SUBCOMMANDS = [
            cls._create_command_for_api(api)
            for api in apis
            if api.__class__ is not StaticSampleSignalExchangeAPI
        ]

    @classmethod
    def _create_command_for_api(
        cls, api: SignalExchangeAPI
    ) -> t.Type[command_base.Command]:
        """Don't try this at home!"""

        class _GeneratedUpdateCommand(_UpdateCollabCommand):
            _API_CLS = api.__class__

        return _GeneratedUpdateCommand


class ConfigCollabDeleteCommand(command_base.Command):
    """Delete collaborations"""

    @classmethod
    def get_name(cls) -> str:
        return "delete"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        ap.add_argument("collab_name", help="the collab to delete")

    def __init__(self, collab_name: str) -> None:
        self.collab_name = collab_name

    def execute(self, settings: CLISettings) -> None:
        collab = settings.get_collab(self.collab_name)
        if collab is None:
            raise CommandError("No such collab", 2)
        settings._state.delete_collab(collab)  # TODO clean private member access


class ConfigCollabCommand(command_base.CommandWithSubcommands):
    """Configure collaborations"""

    _SUBCOMMANDS = [
        ConfigCollabListCommand,
        ConfigCollabForAPICommand,
        ConfigCollabDeleteCommand,
    ]

    @classmethod
    def get_name(cls) -> str:
        return "collab"

    def execute(self, settings: CLISettings) -> None:
        ConfigCollabListCommand().execute(settings)


class ConfigSignalCommand(command_base.Command):
    """Configure signal types"""

    @classmethod
    def get_name(cls) -> str:
        return "signal"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        action = ap.add_argument(
            "action",
            choices=["list"],
            default="list",
            help="what to do",
        )

    def __init__(self, action: str) -> None:
        self.action = {
            "list": self.execute_list,
        }[action]

    def execute(self, settings: CLISettings) -> None:
        self.action(settings)

    def execute_list(self, settings: CLISettings) -> None:
        collabs = settings.get_all_collabs()
        for api, name in sorted((c.api, c.name) for c in collabs):
            print(api, name)


class ConfigContentCommand(command_base.Command):
    """Configure content types"""

    @classmethod
    def get_name(cls) -> str:
        return "content"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        ap.add_argument(
            "--list",
            action="store_true",
            help="list the names of Content Types (default action)",
        )

    def execute(self, settings: CLISettings) -> None:
        content_types = settings.get_all_content_types()
        for name in sorted(c.get_name() for c in content_types):
            print(name)


class ConfigAPICommand(command_base.Command):
    """Configure apis"""

    @classmethod
    def get_name(cls) -> str:
        return "api"

    @classmethod
    def init_argparse(cls, settings: CLISettings, ap: argparse.ArgumentParser) -> None:
        ap.add_argument(
            "--list",
            action="store_true",
            help="list the names of APIs (default action)",
        )

    def execute(self, settings: CLISettings) -> None:
        apis = settings.get_fetchers()
        for name in sorted(a.get_name() for a in apis):
            print(name)


class ConfigCommand(command_base.CommandWithSubcommands):
    """Configure the CLI"""

    _SUBCOMMANDS = [
        ConfigCollabCommand,
        ConfigSignalCommand,
        ConfigContentCommand,
        ConfigAPICommand,
    ]
